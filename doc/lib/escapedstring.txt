
==================
csx._EscapedString
==================

`_EscapedString` strips comments and quoted strings (storing the latter for
later reinsertion) from its `str` argument, so that they can be processed by
`csx._TokenStream` and `csx._Renderable` without any text embedded in those
comments and quoted strings being mistaken for elements of CSX structure. ::

    >>> from csx import _EscapedString

    >>> music = _EscapedString("""
    ...
    ...   /*  Year: 1956
    ...    *  Length: 2'21"
    ...    */
    ...
    ...   track {
    ...     title: "Ain't Got No Home";
    ...     artist: 'Clarence "Frogman" Henry';
    ...   }
    ...
    ... """)

Passing an `_EscapedString` instance to `str()` returns the string with
comments and extraneous whitespace removed. ::

    >>> print(music)
    track { title: "Ain't Got No Home"; artist: 'Clarence "Frogman" Henry'; }

In the underlying `str` object, comments are removed (although any embedded
newlines are preserved to maintain correct line counts), `str.format`-style
replacement fields are substituted for quoted strings, and braces are doubled
to prevent them from interfering with `str.format()`. ::

    >>> music[:]
    '\n\n  \n\n\n\n  track {{\n    title: {0};\n    artist: {1};\n  }}\n\n'

Substituted strings are stored in the attribute `subs`. ::

    >>> music.subs
    ['"Ain\'t Got No Home"', '\'Clarence "Frogman" Henry\'']

Whitespace inside substituted strings is preserved ... ::

    >>> spaced = _EscapedString("content: ' a   b '")

    >>> print(spaced)
    content: ' a   b '

... but a quoted substring may *not* contain an embedded newline ... ::

    >>> illegal = _EscapedString("""
    ...
    ...   :before {
    ...     content: "phwoaar ...
    ...     "
    ...   }
    ...
    ... """)
    Traceback (most recent call last):
        ...
    csx.Error: line 4: unfinished string

... even if it's escaped with a backslash. ::

    >>> still_illegal = _EscapedString(r"""
    ...
    ...   :after {
    ...     content: " \
    ...     ... crikey." 
    ...   }
    ...
    ... """)
    Traceback (most recent call last):
        ...
    csx.Error: line 4: unfinished string

Comment markers inside strings are ignored, as are quotes and `/*` markers
inside comments, single quotes inside double-quoted strings, and vice versa.
Backslash-escaped single or double quotes are ignored everywhere. ::

    >>> insane_but_legal = _EscapedString(r"""
    ...
    ...   /* any combination of /*, ', ", "this", 'that', "t'other", etc. */
    ...
    ...   :before { content: "/* or \" or '" }
    ...   :after { content: '*/ or \' or "' }
    ...
    ... """)

    >>> insane_but_legal[:]
    '\n\n  \n\n  :before {{ content: {0} }}\n  :after {{ content: {1} }}\n\n'

    >>> for sub in insane_but_legal.subs:
    ...     print(sub)
    "/* or \" or '"
    '*/ or \' or "'

As previously seen, comments may span multiple lines, but they must eventually
be terminated. ::

    >>> _EscapedString("/* forgot something ...")
    Traceback (most recent call last):
        ...
    csx.Error: line 1: unfinished comment

`@`, `<!--` and `-->` are illegal outside strings and comments ... ::

    >>> _EscapedString("<!--")
    Traceback (most recent call last):
        ...
    csx.Error: line 1: illegal text '<!--'

    >>> _EscapedString("-->")
    Traceback (most recent call last):
        ...
    csx.Error: line 1: illegal text '-->'

    >>> _EscapedString("@")
    Traceback (most recent call last):
        ...
    csx.Error: line 1: illegal text '@'

... but fine inside them. ::

    >>> print(_EscapedString("go: '<!-- hog wild *' /* and --> @here */"))
    go: '<!-- hog wild *'

